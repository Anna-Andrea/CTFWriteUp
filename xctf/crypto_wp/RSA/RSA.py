def long_to_bytes(n):
    """将长整数转换为字节串（替代Crypto.Util.number.long_to_bytes）"""
    if n == 0:
        return b'\x00'

    byte_list = []
    while n > 0:
        byte_list.append(n & 0xff)
        n >>= 8

    return bytes(byte_list[::-1])


def bytes_to_long(s):
    """将字节串转换为长整数（替代Crypto.Util.number.bytes_to_long）"""
    n = 0
    for byte in s:
        n = (n << 8) | byte
    return n


def mod_inverse(a, m):
    """计算模逆（替代Crypto.Util.number.inverse）"""

    # 使用扩展欧几里得算法
    def extended_gcd(a, b):
        if b == 0:
            return (1, 0, a)
        else:
            x0, y0, g = extended_gcd(b, a % b)
            x = y0
            y = x0 - (a // b) * y0
            return (x, y, g)

    x, y, g = extended_gcd(a, m)
    if g != 1:
        raise ValueError("模逆不存在")
    return x % m


# 已知值
c = 8722269075970644434253339592758512788160408912707387632591552130175707843950684315083250494010055435391879036285103810263591951437829414438640307561645721347859659807138051841516634704123100270651976676182059252251162982609391666023674158274992400910869692389001622774140191223807887675081808561012755545464977015973615407965906513878979919700065923364884766974187303774330319143647840846354404070430118235352622445115153298578370521811697710289716188726587743282814946239856766713516166990341116198180068191759095913957606379780234116317390622824096667107736103270907349927467971817639795094030622157581511033950777
n = 10466186506773626671397261081802640650185744558208505628349249045496105597268556020207175016523119333667851114848452038431498926527983706092607207796937431312520131882751891731564121558651246025754915145600686076505962750195353958781726515647847167067621799990588328894365930423844435964506372428647802381074584935050067254029262890188260006596141011807724688556673520261743199388391094490191001701011230322653422314758778116196105077883955436582364267530633358016652912054880813710531145973799193443828969535902856467548523653920307742364119002349899553478815101092655897400295925170383678499125295006364960124859003
pq = 10466186506773626671397261081802640650185744558208505628349249045496105597268556020207175016523119333667851114848452038431498926527983706092607207796937431312520131882751891731564121558651246025754915145600686076505962750195353958781726515647847167067621799990588328894365930423844435964506372428647802381074488896197029704465200125337817646702009123916866455067019234171839614862660036737875747177391796376553159880972782837853473250804807544086701088829096838316550146794766718580877976153967582795248676367265069623900208276878140709691073369415161936376086988069213820933152601453587292943483693378833664901178324
qp = 10466186506773626671397261081802640650185744558208505628349249045496105597268556020207175016523119333667851114848452038431498926527983706092607207796937431312520131882751891731564121558651246025754915145600686076505962750195353958781726515647847167067621799990588328894365930423844435964506372428647802381074475956379708898904933143429835002718457573266164923043251954374464149976302585916538814746811455883837138715445492053610047383292461097590195481556557381952895539341802954749542143253491617052100969586396996063822508764438280468492894012685918249843558593322831683872737943676955669923498182824352081785243246

# 计算 p 和 q
p = n - pq
q = n - qp

print(f"计算得到的 p: {p}")
print(f"计算得到的 q: {q}")
print(f"验证 n = p * q: {n == p * q}")

# 如果验证成功，继续解密
if n == p * q:
    # 计算欧拉函数 φ(n)
    phi = (p - 1) * (q - 1)

    # 计算私钥 d
    e = 65537
    d = mod_inverse(e, phi)

    # 解密
    m = pow(c, d, n)

    # 转换为字节并输出
    flag_bytes = long_to_bytes(m)
    try:
        flag = flag_bytes.decode('utf-8') #flag{719014b3-c4e1-4f81-a7be-b4f0d65c9e10}
        print(f"解密后的 flag: {flag}")
    except UnicodeDecodeError:
        print(f"解密后的字节: {flag_bytes}")
        print("可能包含非UTF-8字符")
else:
    print("计算错误，请检查推导过程")